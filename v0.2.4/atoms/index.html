<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Atoms extraction · MultivariateMoments</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MultivariateMoments</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Index</a></li><li><a class="toctext" href="../moments/">Moments and expectation</a></li><li class="current"><a class="toctext" href>Atoms extraction</a><ul class="internal"><li><a class="toctext" href="#Moment-matrix-1">Moment matrix</a></li><li><a class="toctext" href="#Atomic-measure-1">Atomic measure</a></li><li><a class="toctext" href="#Atoms-extraction-1">Atoms extraction</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Atoms extraction</a></li></ul><a class="edit-page" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/master/docs/src/atoms.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Atoms extraction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Atoms-extration-1" href="#Atoms-extration-1">Atoms extration</a></h1><h2><a class="nav-anchor" id="Moment-matrix-1" href="#Moment-matrix-1">Moment matrix</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateMoments.MomentMatrix" href="#MultivariateMoments.MomentMatrix"><code>MultivariateMoments.MomentMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">mutable struct MomentMatrix{T, MT &lt;: AbstractMonomial, MVT &lt;: AbstractVector{MT}} &lt;: AbstractMeasureLike{T}
    Q::SymMatrix{T}
    x::MVT
    support::Union{Nothing, AlgebraicSet}
end</code></pre><p>Measure <span>$\nu$</span> represented by the moments of the monomial matrix <span>$x x^\top$</span> in the symmetric matrix <code>Q</code>. The set of points that are zeros of all the polynomials <span>$p$</span> such that <span>$\mathbb{E}_{\nu}[p] = 0$</span> is stored in the field <code>support</code> when it is computed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateMoments.moment_matrix" href="#MultivariateMoments.moment_matrix"><code>MultivariateMoments.moment_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">moment_matrix(μ::Measure, x)</code></pre><p>Creates a matrix the moment matrix for the moment matrix  <span>$x x^\top$</span> using the moments of <code>μ</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateMoments.SymMatrix" href="#MultivariateMoments.SymMatrix"><code>MultivariateMoments.SymMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct SymMatrix{T} &lt;: AbstractMatrix{T}
    Q::Vector{T}
    n::Int
end</code></pre><p>Symmetric <span>$n \times n$</span> matrix storing the vectorized upper triangular part of the matrix in the <code>Q</code> vector (this corresponds to the vectorized form of <code>MathOptInterface.PositiveSemidefiniteConeTriangle</code>). It implement the <code>AbstractMatrix</code> interface except for <code>setindex!</code> as it might break its symmetry. The <a href="#MultivariateMoments.symmetric_setindex!"><code>symmetric_setindex!</code></a> function should be used instead.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateMoments.symmetric_setindex!" href="#MultivariateMoments.symmetric_setindex!"><code>MultivariateMoments.symmetric_setindex!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">symmetric_setindex!(Q::SymMatrix, value, i::Integer, j::Integer)</code></pre><p>Set <code>Q[i, j]</code> and <code>Q[j, i]</code> to the value <code>value</code>.</p></div></div></section><h2><a class="nav-anchor" id="Atomic-measure-1" href="#Atomic-measure-1">Atomic measure</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateMoments.WeightedDiracMeasure" href="#MultivariateMoments.WeightedDiracMeasure"><code>MultivariateMoments.WeightedDiracMeasure</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct WeightedDiracMeasure{T}
    center::Vector{T}
    weight::T
end</code></pre><p>Represents a weighted dirac measure with centered at <code>center</code> and with weight <code>weight</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateMoments.AtomicMeasure" href="#MultivariateMoments.AtomicMeasure"><code>MultivariateMoments.AtomicMeasure</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct AtomicMeasure{T, AT, V} &lt;: AbstractMeasureLike{T}
    variables::V                           # Vector/Tuple of variables
    atoms::Vector{WeightedDiracMeasure{T, AT}} # Atoms of the measure
end</code></pre><p>An measure is said to be <em>atomic</em> if it is a sum of weighted dirac measures. For instance, <span>$\eta = 2 \delta_{(1, 0)} + 3 \delta_{(1/2, 1/2)}$</span> is an atomic measure since it is a sum of the diracs centered at <span>$(1, 0)$</span> and <span>$(1/2, 1/2)$</span> and weighted respectively by 2 and 3. That is, <span>$\mathbb{E}_{\eta}[p] = 2p(1, 0) + 3p(1/2, 1/2)$</span>.</p><p>The <code>AtomicMeasure</code> struct stores an atomic measure where <code>variables</code> contains the variables and <code>atoms</code> contains atoms of the measure.</p></div></div></section><h2><a class="nav-anchor" id="Atoms-extraction-1" href="#Atoms-extraction-1">Atoms extraction</a></h2><p>Given a <code>MomentMatrix</code> with a positive semidefinite moment matrix, an algebraic system for which the set of solution is a superset of the support of the measure. If the measure is atomic and the <code>MomentMatrix</code> contains enough moments, the algebraic system will only have a finite number of solutions which are the centers of the diracs of the measure.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateMoments.computesupport!" href="#MultivariateMoments.computesupport!"><code>MultivariateMoments.computesupport!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">MultivariateMoments.computesupport!(ν::MomentMatrix, ranktol, [dec])</code></pre><p>Computes the <code>support</code> field of <code>ν</code>. The <code>ranktol</code> and <code>dec</code> parameters are passed as is to the <a href="#MultivariateMoments.lowrankchol"><code>lowrankchol</code></a> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateMoments.extractatoms" href="#MultivariateMoments.extractatoms"><code>MultivariateMoments.extractatoms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">extractatoms(ν::MomentMatrix, ranktol, [dec])</code></pre><p>Return an <code>AtomicMeasure</code> with the atoms of <code>ν</code> if it is atomic or <code>nothing</code> if <code>ν</code> is not atomic. The <code>ranktol</code> and <code>dec</code> parameters are passed as is to the <a href="#MultivariateMoments.lowrankchol"><code>lowrankchol</code></a> function.</p></div></div></section><p>This system is obtained from a low rank cholesky decomposition of the moment matrix. This decomposition can either be obtained by a cholesky or SVD decomposition from which we remove the rows corresponding to the negligeable eigenvalues/singular values.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateMoments.LowRankChol" href="#MultivariateMoments.LowRankChol"><code>MultivariateMoments.LowRankChol</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LowRankChol</code></pre><p>Method for computing a <span>$r \times n$</span> matrix <code>U</code> of a <span>$n \times n$</span> rank <span>$r$</span> psd matrix <code>Q</code> such that <code>Q = U&#39;U</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateMoments.ShiftChol" href="#MultivariateMoments.ShiftChol"><code>MultivariateMoments.ShiftChol</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ShiftChol &lt;: LowRankChol</code></pre><p>Shift the matrix by <code>shift</code> times the identity matrix before cholesky.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateMoments.SVDChol" href="#MultivariateMoments.SVDChol"><code>MultivariateMoments.SVDChol</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SVDChol &lt;: LowRankChol</code></pre><p>Use SVD decomposition.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MultivariateMoments.lowrankchol" href="#MultivariateMoments.lowrankchol"><code>MultivariateMoments.lowrankchol</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">MultivariateMoments.lowrankchol(Q::AbstractMatrix, dec::LowRankChol, ranktol)</code></pre><p>Returns a <span>$r \times n$</span> matrix <span>$U$</span> of a <span>$n \times n$</span> rank <span>$r$</span> positive semidefinite matrix <span>$Q$</span> such that <span>$Q = U^\top U$</span>. The rank of <span>$Q$</span> is the number of singular values larger than <code>ranktol</code><span>${} \cdot \sigma_1$</span> where <span>$\sigma_1$</span> is the largest singular value.</p></div></div></section><footer><hr/><a class="previous" href="../moments/"><span class="direction">Previous</span><span class="title">Moments and expectation</span></a></footer></article></body></html>
