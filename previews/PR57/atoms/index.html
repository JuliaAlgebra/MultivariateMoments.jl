<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Atoms extraction · MultivariateMoments</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MultivariateMoments</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><a class="tocitem" href="../moments/">Moments and expectation</a></li><li class="is-active"><a class="tocitem" href>Atoms extraction</a><ul class="internal"><li><a class="tocitem" href="#Vectorized-matrix"><span>Vectorized matrix</span></a></li><li><a class="tocitem" href="#Moment-matrix"><span>Moment matrix</span></a></li><li><a class="tocitem" href="#Atomic-measure"><span>Atomic measure</span></a></li><li><a class="tocitem" href="#Atoms-extraction"><span>Atoms extraction</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Atoms extraction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Atoms extraction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/master/docs/src/atoms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Atoms-extration"><a class="docs-heading-anchor" href="#Atoms-extration">Atoms extration</a><a id="Atoms-extration-1"></a><a class="docs-heading-anchor-permalink" href="#Atoms-extration" title="Permalink"></a></h1><h2 id="Vectorized-matrix"><a class="docs-heading-anchor" href="#Vectorized-matrix">Vectorized matrix</a><a id="Vectorized-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorized-matrix" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.SymMatrix" href="#MultivariateMoments.SymMatrix"><code>MultivariateMoments.SymMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SymMatrix{T} &lt;: AbstractMatrix{T}
    Q::Vector{T}
    n::Int
end</code></pre><p>Symmetric <span>$n \times n$</span> matrix storing the vectorized upper triangular part of the matrix in the <code>Q</code> vector (this corresponds to the vectorized form of <code>MathOptInterface.PositiveSemidefiniteConeTriangle</code>). It implement the <code>AbstractMatrix</code> interface except for <code>setindex!</code> as it might break its symmetry. The <a href="#MultivariateMoments.symmetric_setindex!"><code>symmetric_setindex!</code></a> function should be used instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/symmatrix.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.VectorizedHermitianMatrix" href="#MultivariateMoments.VectorizedHermitianMatrix"><code>MultivariateMoments.VectorizedHermitianMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VectorizedHermitianMatrix{T} &lt;: AbstractMatrix{Complex{T}}
    Q::Vector{T}
    n::Int
end</code></pre><p>Hermitian <span>$n \times n$</span> matrix storing the vectorized upper triangular real part of the matrix followed by the vectorized upper triangular imaginary part in the <code>Q</code> vector (this corresponds to the vectorized form of <code>ComplexOptInterface.HermitianPositiveSemidefiniteConeTriangle</code>). It implement the <code>AbstractMatrix</code> interface except for <code>setindex!</code> as it might break its symmetry. The <a href="#MultivariateMoments.symmetric_setindex!"><code>symmetric_setindex!</code></a> function should be used instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/hermitian_matrix.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.square_getindex" href="#MultivariateMoments.square_getindex"><code>MultivariateMoments.square_getindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">square_getindex!(Q::SymMatrix, I)</code></pre><p>Return the <code>SymMatrix</code> corresponding to <code>Q[I, I]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/symmatrix.jl#L64-L68">source</a></section><section><div><pre><code class="nohighlight hljs">square_getindex!(Q::VectorizedHermitianMatrix, I)</code></pre><p>Return the <code>VectorizedHermitianMatrix</code> corresponding to <code>Q[I, I]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/hermitian_matrix.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.symmetric_setindex!" href="#MultivariateMoments.symmetric_setindex!"><code>MultivariateMoments.symmetric_setindex!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">symmetric_setindex!(Q::SymMatrix, value, i::Integer, j::Integer)</code></pre><p>Set <code>Q[i, j]</code> and <code>Q[j, i]</code> to the value <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/symmatrix.jl#L83-L87">source</a></section><section><div><pre><code class="nohighlight hljs">symmetric_setindex!(Q::VectorizedHermitianMatrix, value, i::Integer, j::Integer)</code></pre><p>Set <code>Q[i, j]</code> to the value <code>value</code> and <code>Q[j, i]</code> to the value <code>-value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/hermitian_matrix.jl#L115-L119">source</a></section></article><h2 id="Moment-matrix"><a class="docs-heading-anchor" href="#Moment-matrix">Moment matrix</a><a id="Moment-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Moment-matrix" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.MomentMatrix" href="#MultivariateMoments.MomentMatrix"><code>MultivariateMoments.MomentMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MomentMatrix{T, B&lt;:MultivariateBases.AbstractPolynomialBasis, MT&lt;:AbstractMatrix{T}} &lt;: AbstractMeasureLike{T}
    Q::MT
    basis::B
    support::Union{Nothing, AlgebraicSet}
end</code></pre><p>Measure <span>$\nu$</span> represented by the moments of the monomial matrix <span>$x x^\top$</span> in the symmetric matrix <code>Q</code>. The set of points that are zeros of all the polynomials <span>$p$</span> such that <span>$\mathbb{E}_{\nu}[p] = 0$</span> is stored in the field <code>support</code> when it is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/moment_matrix.jl#L6-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.moment_matrix" href="#MultivariateMoments.moment_matrix"><code>MultivariateMoments.moment_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moment_matrix(μ::Measure, x)</code></pre><p>Creates a matrix the moment matrix for the moment matrix  <span>$x x^\top$</span> using the moments of <code>μ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/moment_matrix.jl#L76-L80">source</a></section></article><h2 id="Atomic-measure"><a class="docs-heading-anchor" href="#Atomic-measure">Atomic measure</a><a id="Atomic-measure-1"></a><a class="docs-heading-anchor-permalink" href="#Atomic-measure" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.WeightedDiracMeasure" href="#MultivariateMoments.WeightedDiracMeasure"><code>MultivariateMoments.WeightedDiracMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct WeightedDiracMeasure{T}
    center::Vector{T}
    weight::T
end</code></pre><p>Represents a weighted dirac measure with centered at <code>center</code> and with weight <code>weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/atomic.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.AtomicMeasure" href="#MultivariateMoments.AtomicMeasure"><code>MultivariateMoments.AtomicMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AtomicMeasure{T, AT, V} &lt;: AbstractMeasureLike{T}
    variables::V                           # Vector/Tuple of variables
    atoms::Vector{WeightedDiracMeasure{T, AT}} # Atoms of the measure
end</code></pre><p>An measure is said to be <em>atomic</em> if it is a sum of weighted dirac measures. For instance, <span>$\eta = 2 \delta_{(1, 0)} + 3 \delta_{(1/2, 1/2)}$</span> is an atomic measure since it is a sum of the diracs centered at <span>$(1, 0)$</span> and <span>$(1/2, 1/2)$</span> and weighted respectively by 2 and 3. That is, <span>$\mathbb{E}_{\eta}[p] = 2p(1, 0) + 3p(1/2, 1/2)$</span>.</p><p>The <code>AtomicMeasure</code> struct stores an atomic measure where <code>variables</code> contains the variables and <code>atoms</code> contains atoms of the measure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/atomic.jl#L21-L32">source</a></section></article><h2 id="Atoms-extraction"><a class="docs-heading-anchor" href="#Atoms-extraction">Atoms extraction</a><a id="Atoms-extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Atoms-extraction" title="Permalink"></a></h2><p>Given a <code>MomentMatrix</code> containing the moments of an atomic measure, <a href="#MultivariateMoments.atomic_measure"><code>atomic_measure</code></a> attempts to recover the dirac centers and weights by first computing an algebraic system with the atom centers as solution with <a href="#MultivariateMoments.compute_support!"><code>compute_support!</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.compute_support!" href="#MultivariateMoments.compute_support!"><code>MultivariateMoments.compute_support!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function compute_support!(ν::MomentMatrix, rank_check, solver) end</code></pre><p>Computes the <code>support</code> field of <code>ν</code> wth <code>solver</code> using a low-rank decomposition with the rank evaluated with <code>rank_check</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/extract.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.atomic_measure" href="#MultivariateMoments.atomic_measure"><code>MultivariateMoments.atomic_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">atomic_measure(ν::MomentMatrix, rank_check::RankCheck, [dec::LowRankLDLTAlgorithm], [solver::SemialgebraicSets.AbstractAlgebraicSolver])</code></pre><p>Return an <code>AtomicMeasure</code> with the atoms of <code>ν</code> if it is atomic or <code>nothing</code> if <code>ν</code> is not atomic. The <code>rank_check</code> and <code>dec</code> parameters are passed as is to the <a href="#MultivariateMoments.low_rank_ldlt"><code>low_rank_ldlt</code></a> function. By default, <code>dec</code> is an instance of <a href="#MultivariateMoments.SVDLDLT"><code>SVDLDLT</code></a>. The extraction relies on the solution of a system of algebraic equations. using <code>solver</code>. For instance, given a <a href="#MultivariateMoments.MomentMatrix"><code>MomentMatrix</code></a>, <code>μ</code>, the following extract atoms using a <code>rank_check</code> of <code>1e-4</code> for the low-rank decomposition and homotopy continuation to solve the obtained system of algebraic equations.</p><pre><code class="language-julia hljs">using HomotopyContinuation
solver = SemialgebraicSetsHCSolver(; compile = false)
atoms = atomic_measure(ν, 1e-4, solver)</code></pre><p>If no solver is given, the default solver of SemialgebraicSets is used which currently computes the Gröbner basis, then the multiplication matrices and then the Schur decomposition of a random combination of these matrices. For floating point arithmetics, homotopy continuation is recommended as it is more numerically stable than Gröbner basis computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/extract.jl#L99-L120">source</a></section></article><p>For the first step of <a href="#MultivariateMoments.compute_support!"><code>compute_support!</code></a>, there are two approaches. The first one is to exploit the <em>flat extension</em> to directly obtain the multiplication matrices.</p><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.FlatExtension" href="#MultivariateMoments.FlatExtension"><code>MultivariateMoments.FlatExtension</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FlatExtension{
    MMS&lt;:SemialgebraicSets.AbstractMultiplicationMatricesSolver,
}
    multiplication_matrices_solver::MMS
end</code></pre><p>Given a moment matrix satisfying the <em>flat extension</em> property described in [L09, Section 5.3], computes the multiplication matrices using the formula given in [L09, Lemma 6.21] or [LLR08, Section 4.4.4]. Given the multiplication matrices, the solutions are obtained with <code>multiplication_matrices_solver</code>.</p><p>[L09] Laurent, Monique. <em>Sums of squares, moment matrices and optimization over polynomials.</em> Emerging applications of algebraic geometry (2009): 157-270.</p><p>[LLR08] Lasserre, Jean Bernard and Laurent, Monique, and Rostalski, Philipp. <em>Semidefinite characterization and computation of zero-dimensional real radical ideals.</em> Foundations of Computational Mathematics 8 (2008): 607-647.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/flat.jl#L35-L55">source</a></section></article><p>The second approach is to first obtain the image space of the moment matrix, represented as a <a href="#MultivariateMoments.MacaulayNullspace"><code>MacaulayNullspace</code></a> and to then compute the multiplication matrices from this image space. This is implemented by the <a href="#MultivariateMoments.ImageSpaceSolver"><code>ImageSpaceSolver</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.MacaulayNullspace" href="#MultivariateMoments.MacaulayNullspace"><code>MultivariateMoments.MacaulayNullspace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MacaulayNullspace{T,MT&lt;:AbstractMatrix{T},BT}
    matrix::MT
    basis::BT
end</code></pre><p>This matrix with rows indexed by <code>basis</code> can either be interpreted as the right null space of a Macaulay matrix with columns indexed by <code>basis</code> (resp. or the image space of a moment matrix with rows and columns indexed by <code>basis</code>). The value of <code>matrix[i, j]</code> should be interpreted as the value of the <code>i</code>th element of <code>basis</code> for the <code>j</code>th generator of the null space (resp. image) space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/null.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.ImageSpaceSolver" href="#MultivariateMoments.ImageSpaceSolver"><code>MultivariateMoments.ImageSpaceSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ImageSpaceSolver{A&lt;:LowRankLDLTAlgorithm,S&lt;:MacaulayNullspaceSolver}
    ldlt::A
    null::S
end</code></pre><p>Computes the image space of the moment matrix using <code>ldlt</code> and then solve it with <code>null</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/null.jl#L33-L41">source</a></section></article><p>This image space is obtained from a low rank LDLT decomposition of the moment matrix. This decomposition can either be obtained by a cholesky or SVD decomposition from which we remove the rows corresponding to the negligeable eigen/singular values.</p><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.LowRankLDLTAlgorithm" href="#MultivariateMoments.LowRankLDLTAlgorithm"><code>MultivariateMoments.LowRankLDLTAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LowRankLDLTAlgorithm</code></pre><p>Method for computing a <span>$r \times n$</span> matrix <code>U</code> of a <span>$n \times n$</span> rank <span>$r$</span> psd matrix <code>Q</code> such that <code>Q = U&#39;U</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L359-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.ShiftCholeskyLDLT" href="#MultivariateMoments.ShiftCholeskyLDLT"><code>MultivariateMoments.ShiftCholeskyLDLT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShiftCholeskyLDLT &lt;: LowRankLDLTAlgorithm</code></pre><p>Shift the matrix by <code>shift</code> times the identity matrix before cholesky.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L366-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.SVDLDLT" href="#MultivariateMoments.SVDLDLT"><code>MultivariateMoments.SVDLDLT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SVDLDLT &lt;: LowRankLDLTAlgorithm</code></pre><p>Use SVD decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L375-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.low_rank_ldlt" href="#MultivariateMoments.low_rank_ldlt"><code>MultivariateMoments.low_rank_ldlt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MultivariateMoments.low_rank_ldlt(Q::AbstractMatrix, dec::LowRankLDLTAlgorithm, ranktol)</code></pre><p>Returns a <span>$r \times n$</span> matrix <span>$U$</span> of a <span>$n \times n$</span> rank <span>$r$</span> positive semidefinite matrix <span>$Q$</span> such that <span>$Q = U^\top U$</span>. The rank of <span>$Q$</span> is the number of singular values larger than <code>ranktol</code><span>${} \cdot \sigma_1$</span> where <span>$\sigma_1$</span> is the largest singular value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.LowRankLDLT" href="#MultivariateMoments.LowRankLDLT"><code>MultivariateMoments.LowRankLDLT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LowRankLDLT{T,Tr,C&lt;:RankCheck}
    L::Matrix{T}
    singular_values::Vector{Tr}
    rank_check::C
end</code></pre><p>Low-Rank cholesky decomposition <code>L * Diagonal(singular_values) * L&#39;</code> of size <code>(n, r)</code> of a <code>n x n</code> matrix with singular values <code>singular_values[1] &gt; ... &gt; singular_values[n]</code>. The rank was chosen given <code>singular_values</code> using <code>rank_check</code> via the <a href="#MultivariateMoments.rank_from_singular_values"><code>rank_from_singular_values</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L394-L406">source</a></section></article><p>The choice of cutoff between the significant and neglibeable eigen/singular values is parametrized by the following interface:</p><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.RankCheck" href="#MultivariateMoments.RankCheck"><code>MultivariateMoments.RankCheck</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type RankCheck end</code></pre><p>Method for computing the rank with <a href="#MultivariateMoments.rank_from_singular_values"><code>rank_from_singular_values</code></a> based on a list of singular values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.rank_from_singular_values" href="#MultivariateMoments.rank_from_singular_values"><code>MultivariateMoments.rank_from_singular_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rank_from_singular_values(σ, check::RankCheck)</code></pre><p>Return the rank of a matrix with singular values <code>σ</code> (in decreasing order) using <code>check</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.accuracy" href="#MultivariateMoments.accuracy"><code>MultivariateMoments.accuracy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">accuracy(σ, r, check::RankCheck)</code></pre><p>Returns a value measuring the accuracy of the rank check <code>check</code> returning rank <code>r</code>. This is used by <a href="#MultivariateMoments.Echelon"><code>Echelon</code></a> to determine the accuracy to use for the Gaussian elimination.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L17-L23">source</a></section><section><div><pre><code class="nohighlight hljs">accuracy(chol::LowRankLDLT)</code></pre><p>Return the ratio <code>rtol = σ[r+1]/σ[1]</code> where <code>σ</code> is the vector of singular values of the matrix for which <code>chol</code> is the rank-<code>r</code> Cholesky decomposition. This is a good relative tolerance to use with the matrix as <code>σ[r+1]</code> is the first singular value that was discarded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L413-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.doubt" href="#MultivariateMoments.doubt"><code>MultivariateMoments.doubt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">doubt(σ, check::RankCheck)</code></pre><p>Returns a value measuring the doubt of the rank check <code>check</code>. Lower values means more doubt so less certainty. This is used by <a href="#MultivariateMoments.FallbackRank"><code>FallbackRank</code></a> for deciding whether the fallback should be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L34-L41">source</a></section></article><p>The rank check can be chosen among the following:</p><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.UserRank" href="#MultivariateMoments.UserRank"><code>MultivariateMoments.UserRank</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UserRank &lt;: RankCheck
    pagesize::Int
end</code></pre><p>The user chooses the rank given the singular values in a <code>REPL.TerminalMenus.RadioMenu</code> of page size <code>pagesize</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; rank_from_singular_values([1, 1e-1, 5e-2, 1e-5, 5e-6], UserRank())
Choose the last significant singular value:
   1.0
   0.1
 &gt; 0.05
   1.0e-5
   5.0e-6
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L44-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.FixedRank" href="#MultivariateMoments.FixedRank"><code>MultivariateMoments.FixedRank</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FixedRank &lt;: RankCheck
    r::Int
end</code></pre><p>The rank is hardcoded to <code>r</code>, independently of the singular values.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rank_from_singular_values([1, 1e-1, 5e-2, 1e-5, 5e-6], FixedRank(3))
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L77-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.FixedRanks" href="#MultivariateMoments.FixedRanks"><code>MultivariateMoments.FixedRanks</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct FixedRanks &lt;: RankCheck
    r::Vector{Int}
    current::Int
end</code></pre><p>The <code>i</code>th rank is hardcoded to <code>r[i]</code>, independently of the singular values. The field <code>current</code> indicates how many ranks have already been asked. When <code>current</code> is <code>length(r)</code>, no rank can be asked anymore.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; check = FixedRanks([2, 3])
FixedRanks([2, 3], 0)

julia&gt; rank_from_singular_values([1, 1e-1, 5e-5, 1e-5, 5e-6], check)
2

julia&gt; rank_from_singular_values([1, 1e-1, 5e-2, 1e-5, 5e-6], check)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L97-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.AbsoluteRankTol" href="#MultivariateMoments.AbsoluteRankTol"><code>MultivariateMoments.AbsoluteRankTol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AbsoluteRankTol{T} &lt;: RankCheck
    tol::T
end</code></pre><p>The rank is the number of singular values that are strictly larger than <code>tol</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rank_from_singular_values([1, 1e-1, 5e-2, 1e-5, 5e-6], AbsoluteRankTol(1e-4))
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L140-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.LeadingRelativeRankTol" href="#MultivariateMoments.LeadingRelativeRankTol"><code>MultivariateMoments.LeadingRelativeRankTol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LeadingRelativeRankTol{T} &lt;: RankCheck
    tol::T
end</code></pre><p>The rank is the number of singular values that are strictly larger than <code>tol * maximum(σ)</code> where <code>maximum(σ)</code> is the largest singular value.</p><p><strong>Example</strong></p><p>When the matrix is obtained from a homogeneous problem where the scaling is irrelevant, <code>LeadingRelativeRankTol</code> may be preferable to <a href="#MultivariateMoments.AbsoluteRankTol"><code>AbsoluteRankTol</code></a> as shown below</p><pre><code class="language-julia-repl hljs">julia&gt; rank_from_singular_values(1e6 * [1, 1e-1, 5e-2, 1e-5, 5e-6], AbsoluteRankTol(1e-4))
5

julia&gt; rank_from_singular_values(1e6 * [1, 1e-1, 5e-2, 1e-5, 5e-6], LeadingRelativeRankTol(1e-4))
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L162-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.DifferentialRankTol" href="#MultivariateMoments.DifferentialRankTol"><code>MultivariateMoments.DifferentialRankTol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DifferentialRankTol{T} &lt;: RankCheck
    tol::T
end</code></pre><p>The rank is the number of singular values before a singular value (not included) is <code>tol</code> times the previous one (included).</p><p><strong>Example</strong></p><p>It is sometimes difficult to figure out the tolerance to use in <a href="#MultivariateMoments.LeadingRelativeRankTol"><code>LeadingRelativeRankTol</code></a>. For instance, choosing <code>1e-3</code> will consider <code>1e-3</code> in the example below as not part of the rank while <code>DifferentialRankTol</code> would include it because it is close to the previous singular value.</p><pre><code class="language-julia-repl hljs">julia&gt; rank_from_singular_values([1, 1e-1, 5e-2, 1e-2, 5e-3, 1e-3, 1e-6, 5e-7], LeadingRelativeRankTol(1e-3))
5

julia&gt; rank_from_singular_values([1, 1e-1, 5e-2, 1e-2, 5e-3, 1e-3, 1e-6, 5e-7], DifferentialRankTol(1e-2))
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L195-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.LargestDifferentialRank" href="#MultivariateMoments.LargestDifferentialRank"><code>MultivariateMoments.LargestDifferentialRank</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LargestDifferentialRank &lt;: RankCheck
end</code></pre><p>The rank is the number of singular values until the singular value that has the largest ratio with the next singular value.</p><p><strong>Example</strong></p><p>It is sometimes difficult to figure out the tolerance to use in <a href="#MultivariateMoments.DifferentialRankTol"><code>DifferentialRankTol</code></a>. For instance, choosing <code>1e-2</code> will consider <code>1e-2</code>, <code>5e-2</code> and <code>1e-3</code> in the example below as not part of the rank while <code>LargestDifferentialRank</code> would include them because there is a largest gap later.</p><pre><code class="language-julia-repl hljs">julia&gt; rank_from_singular_values([1, 1e-2, 5e-2, 1e-3, 1e-6, 5e-7], DifferentialRankTol(1e-2))
1

julia&gt; rank_from_singular_values([1, 1e-2, 5e-2, 1e-3, 1e-6, 5e-7], LargestDifferentialRank())
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L231-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.FallbackRank" href="#MultivariateMoments.FallbackRank"><code>MultivariateMoments.FallbackRank</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FallbackRank{T,D,F} &lt;: RankCheck
    tol::T
    default::D
    fallback::F
end</code></pre><p>Defaults to checking the rank with <code>default</code> and falls back to <code>fallback</code> if the <a href="#MultivariateMoments.doubt"><code>doubt</code></a> is strictly larger than <code>tol</code>. By default, <code>fallback</code> is <a href="#MultivariateMoments.UserRank"><code>UserRank</code></a>.</p><p><strong>Example</strong></p><p>The advantage of <a href="#MultivariateMoments.UserRank"><code>UserRank</code></a> is that the user get to see if the rank check is ambiguous and act accordingly. The downside is that it might be cumbersome if there are many rank checks to do. With <code>FallbackRank</code>, the user only has to sort out the tricky ones. In the example below, the first example is handled by <a href="#MultivariateMoments.LargestDifferentialRank"><code>LargestDifferentialRank</code></a>. For the second one, the user sees that this is a tricky choice and can manually choose one of the two ranks, then see the result of the rest of his code using this value of the code and then choose the other rank and see the impact of this different choice.</p><pre><code class="language-julia hljs">julia&gt; check = FallbackRank(1e-1, LargestDifferentialRank())
FallbackRank{Float64, LargestDifferentialRank, UserRank}(0.1, LargestDifferentialRank(), UserRank(8))

julia&gt; rank_from_singular_values([1, 1e-2, 5e-2, 1e-3, 1e-6, 5e-7], check)
4

julia&gt; rank_from_singular_values([1, 1e-2, 5e-2, 1e-3, 5e-6, 5e-7], check)
Choose the last significant singular value:
 &gt; 1.0
   0.01
   0.05
   0.001
   5.0e-6
   5.0e-7
1

julia&gt; rank_from_singular_values([1, 1e-2, 5e-2, 1e-3, 5e-6, 5e-7], check)
Choose the last significant singular value:
   1.0
   0.01
   0.05
 &gt; 0.001
   5.0e-6
   5.0e-7
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/rank.jl#L278-L328">source</a></section></article><p>Given the <a href="#MultivariateMoments.MacaulayNullspace"><code>MacaulayNullspace</code></a>, there are two approaches implemented to obtain the moment matrices:</p><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.ShiftNullspace" href="#MultivariateMoments.ShiftNullspace"><code>MultivariateMoments.ShiftNullspace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ShiftNullspace{C&lt;:RankCheck} &lt;: MacaulayNullspaceSolver
    check::C
end</code></pre><p>From the <a href="#MultivariateMoments.MacaulayNullspace"><code>MacaulayNullspace</code></a>, computes multiplication matrices by exploiting the shift property of the rows [DBD12]. The rank check <code>check</code> is used to determine the standard monomials among the row indices of the null space.</p><p>[DBD12] Dreesen, Philippe, Batselier, Kim, and De Moor, Bart. <em>Back to the roots: Polynomial system solving, linear algebra, systems theory.</em> IFAC Proceedings Volumes 45.16 (2012): 1203-1208.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/shift.jl#L80-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.Echelon" href="#MultivariateMoments.Echelon"><code>MultivariateMoments.Echelon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Echelon
end</code></pre><p>Given a <a href="#MultivariateMoments.MacaulayNullspace"><code>MacaulayNullspace</code></a>, computes its echelon form (corresponding to the <em>Canonical Null Space</em> of [D13]) with Gaussian elimination. From this echelon form, the left null space can easily be computed using using [HL05, (8)]. This left null space forms a system of polynomial equations.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the context of <a href="#MultivariateMoments.compute_support!"><code>compute_support!</code></a>, if the <a href="#MultivariateMoments.MacaulayNullspace"><code>MacaulayNullspace</code></a> was obtained using <a href="#MultivariateMoments.SVDLDLT"><code>SVDLDLT</code></a>, the left null space can easily be obtained from the singular vectors corresponding to the negligeable singular values that were removed. However, as mentioned [LLR08, Section 4.4.5], these will usually give an overdetermined bases. As shown in [S04, Section 10.8.2], it is desirable to avoid overdetermined bases because it could lead to inconsistencies in the basis for numerical reasons. For this reason, this method computes the left null space from the echelon form of the significant singular values instead.</p></div></div><p>Let <code>B</code> be the set of monomials corresponding to the rows of the pivots of this echelon form.  If the moment matrix satisfies the <em>flat extension</em> property described in [L09, Section 5.3] then all monomials of the <em>border</em> of <code>B</code> (as defined in [LLR08, (2.3)]) will correspond to a row of of the matrix. In that case, the polynomial of the system obtained by [HL05, (8)] form a <em>rewriting family</em> for <code>B</code> [L09, (2.16)] a.k.a. a <code>B</code><em>-border prebasis</em> (as defined in [LLR08, (2.4)]). Therefore, they can be used to compute multiplication matrices.</p><p>[HL05] Henrion, D. &amp; Lasserre, J-B. <em>Detecting Global Optimality and Extracting Solutions of GloptiPoly</em> 2005</p><p>[D13] Dreesen, Philippe. <em>Back to the Roots: Polynomial System Solving Using Linear Algebra</em> Ph.D. thesis (2013)</p><p>[L09] Laurent, Monique. <em>Sums of squares, moment matrices and optimization over polynomials.</em> Emerging applications of algebraic geometry (2009): 157-270.</p><p>[LLR08] Lasserre, Jean Bernard and Laurent, Monique, and Rostalski, Philipp. <em>Semidefinite characterization and computation of zero-dimensional real radical ideals.</em> Foundations of Computational Mathematics 8 (2008): 607-647.</p><p>[S04] Stetter, Hans J. <em>Numerical polynomial algebra.</em> Society for Industrial and Applied Mathematics, 2004.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/echelon.jl#L28-L80">source</a></section></article><p>The <a href="#MultivariateMoments.Echelon"><code>Echelon</code></a> uses the RowEchelon package to determine the standard monomials (which is not numerically stable) while the <a href="#MultivariateMoments.ShiftNullspace"><code>ShiftNullspace</code></a> uses the following function internally which is based on SVD so it should have better numerical behavior.</p><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.standard_monomials_and_border" href="#MultivariateMoments.standard_monomials_and_border"><code>MultivariateMoments.standard_monomials_and_border</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function standard_monomials_and_border(
    null::MacaulayNullspace,
    rank_check,
)</code></pre><p>Computes the set of standard monomials using the <em>greedy sieve</em> algorithm presented in [LLR08, Algorithm 1].</p><p>[LLR08] Lasserre, Jean Bernard and Laurent, Monique, and Rostalski, Philipp. <em>Semidefinite characterization and computation of zero-dimensional real radical ideals.</em> Foundations of Computational Mathematics 8 (2008): 607-647.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/shift.jl#L3-L15">source</a></section></article><p>Once the center of the atoms are determined, a linear system is solved to determine the weights corresponding to each dirac. By default, <a href="#MultivariateMoments.MomentMatrixWeightSolver"><code>MomentMatrixWeightSolver</code></a> is used by <a href="#MultivariateMoments.atomic_measure"><code>atomic_measure</code></a> so that if there are small differences between moment values corresponding to the same monomial in the matrix (which can happen if these moments were computed numerically by a semidefinite proramming solvers, e.g., with <a href="https://github.com/jump-dev/SumOfSquares.jl">SumOfSquares</a>), the linear system handles that automatically.</p><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.MomentMatrixWeightSolver" href="#MultivariateMoments.MomentMatrixWeightSolver"><code>MultivariateMoments.MomentMatrixWeightSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MomentMatrixWeightSolver
    rtol::T
    atol::T
end</code></pre><p>Given a moment matrix <code>ν</code> and the atom centers, determine the weights by solving a linear system over all the moments of the moment matrix, keeping duplicates (e.g., entries corresponding to the same monomial).</p><p>If the moment values corresponding to the same monomials are known to be equal prefer <a href="#MultivariateMoments.MomentVectorWeightSolver"><code>MomentVectorWeightSolver</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/extract.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultivariateMoments.MomentVectorWeightSolver" href="#MultivariateMoments.MomentVectorWeightSolver"><code>MultivariateMoments.MomentVectorWeightSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MomentVectorWeightSolver{T}
    rtol::T
    atol::T
end</code></pre><p>Given a moment matrix <code>ν</code> and the atom centers, first convert the moment matrix to a vector of moments, using <a href="../moments/#MultivariateMoments.measure"><code>measure(ν; rtol=rtol, atol=atol)</code></a> and then determine the weights by solving a linear system over the monomials obtained.</p><p>If the moment values corresponding to the same monomials can have small differences, <a href="../moments/#MultivariateMoments.measure"><code>measure</code></a> can throw an error if <code>rtol</code> and <code>atol</code> are not small enough. Alternatively to tuning these tolerances <a href="#MultivariateMoments.MomentVectorWeightSolver"><code>MomentVectorWeightSolver</code></a> can be used instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariateMoments.jl/blob/94428bfc16365ca8529d7c0d7de5ccb91a0ca64a/src/extract.jl#L44-L57">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../moments/">« Moments and expectation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 11 July 2023 08:01">Tuesday 11 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
